defmodule Elxfunc do
def is_compiled(x) do
Enum.member?([:fact,:ack,:tarai,:fib,:union,:intersection,:maplist],x)
end
def primitive([:fact,n]) do fact(n) end
def primitive([:ack,m,n]) do ack(m,n) end
def primitive([:tarai,x,y,z]) do tarai(x,y,z) end
def primitive([:fib,n]) do fib(n) end
def primitive([:union,x,y]) do union(x,y) end
def primitive([:intersection,x,y]) do intersection(x,y) end
def primitive([:maplist,x,fname]) do maplist(x,fname) end
def fact(n) do
cond do
n==0 -> 1
T -> n*fact(n- 1)
end
end
def ack(m,n) do
cond do
m==0 -> n+ 1
n==0 -> ack(m- 1,1)
T -> ack(m- 1,ack(m,n- 1))
end
end
def tarai(x,y,z) do
cond do
x<=y -> y
T -> tarai(tarai(x- 1,y,z),tarai(y- 1,z,x),tarai(z- 1,x,y))
end
end
def fib(n) do
cond do
n<2 -> n
T -> fib(n- 1)+fib(n-2)
end
end
def union(x,y) do
cond do
x== nil or x== [] -> y
Enum.member?(y,hd(x)) -> union(tl(x),y)
T -> [hd(x)|union(tl(x),y)]
end
end
def intersection(x,y) do
cond do
x== nil or x== [] -> []
Enum.member?(y,hd(x)) -> [hd(x)|intersection(tl(x),y)]
T -> intersection(tl(x),y)
end
end
def maplist(x,fname) do
cond do
x== nil or x== [] -> []
T -> [fname.(hd(x))|maplist(tl(x),fname)]
end
end
end
